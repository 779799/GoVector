GoVector
========

This is a small library that you can add to your Go project to
generate a [ShiViz](http://bestchai.bitbucket.org/shiviz/)-compatible
vector-clock timestamped log of events in your distributed system.

* govec/: Contains the Library and all its dependencies
* TestFile.go: A small program to test the library
* exampleprocess-Log.txt: An example log generated by the library

### API

At the high-level the library exports 3 calls:

* govec.Initialize : initialize the local state, returns a reference to govec.GoLog 
* (*govec.GoLog) PrepareSend : wraps a buffer with a vector clock to prepare it to be sent
* (*govec.GoLog) UnpackReceive : unwraps the vector clock from a received buffer

### Usage

Add the govec folder to your project and import it with:

	"import ./govec"

Invoke Initialize once, somewhere at the start of an execution: 

	logger:= govec.Initialize("MyProcessName", ShouldYouSeeLoggingOnScreen, ShouldISendVectorClockonWire, Debug)

Initialize returns a pointer to govec.GoLog (logger var above) and
takes the following arguments:

* MyProcessName (string): local process name; must be unique to your distributed system.
* ShouldYouSeeLoggingOnScreen (bool): whether to print whatever is logged by the library to stdout.
* ShouldISendVectorClockonWire (bool): whether or not PrepareSend wraps buffers with a vector clock (true) or leaves them unchanged (false)
* Debug (bool): print extra diagnostic information to stdout


When you are ready to send a []buffer instead of the following call:

	connection.Write([]buffer)

use this:

	connection.Write(Logger.PrepareSend("Msg description", []buffer))


When receiving a []buffer that was instrumented by the sender, unpack
it using UnpackReceive. That is, after you call Read to read the
[]buffer:

	connection.Read([]buffer)

invoke UnpackReceive :
	
	[]UnpackedBuffer :=  Logger.UnpackReceive("Message Description", []buffer)
	
	
